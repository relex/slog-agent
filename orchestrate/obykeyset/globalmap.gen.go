// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package obykeyset

import (
	"sync"

	"github.com/relex/slog-agent/util"
)

// *pipelineChannelLocalBuffer is the type of wrapper to enclose global object in local cache

type globalPipelineChannelObjectConstructor func(keys []string, onStopped func()) pipelineChannel

type globalPipelineChannelObjectDestructor func(obj pipelineChannel)

type localPipelineChannelWrapperConstructor func(obj pipelineChannel) *pipelineChannelLocalBuffer

// globalPipelineChannelMap keeps a global map of worker channels, each of the channel is linked to a background worker
// The channels can only be added, never removed or replaced, because their references are copied to local cache for fast access
type globalPipelineChannelMap struct {
	globalMap     map[string]pipelineChannel
	globalMutex   *sync.Mutex                            // mutex to protect globalMap
	createObject  globalPipelineChannelObjectConstructor // func to create new global object, called within global mutex
	deleteObject  globalPipelineChannelObjectDestructor  // func to destroy global object
	wrapObject    localPipelineChannelWrapperConstructor // func to wrap global object in local cache
	objectCounter *sync.WaitGroup                        // global object counter, for finalization
}

// localPipelineChannelMap keeps local cache of global channel map for fast access, unprotected by mutex
type localPipelineChannelMap struct {
	localMap  map[string]*pipelineChannelLocalBuffer // local cache of map, append only
	source    *globalPipelineChannelMap              // point to the source channelMap
	keyBuffer []byte                                 // preallocated buffer to merge keys
}

// newGlobalPipelineChannelMap creates a globalPipelineChannelMap
func newGlobalPipelineChannelMap(create globalPipelineChannelObjectConstructor, delete globalPipelineChannelObjectDestructor, wrap localPipelineChannelWrapperConstructor) *globalPipelineChannelMap {
	return &globalPipelineChannelMap{
		globalMap:     make(map[string]pipelineChannel, 2000),
		globalMutex:   &sync.Mutex{},
		createObject:  create,
		deleteObject:  delete,
		wrapObject:    wrap,
		objectCounter: &sync.WaitGroup{},
	}
}

// MakeLocalMap creates an empty local cache for a single log producer (e.g. a connection handled by one goroutine)
func (cm *globalPipelineChannelMap) MakeLocalMap() *localPipelineChannelMap {
	return &localPipelineChannelMap{
		localMap:  make(map[string]*pipelineChannelLocalBuffer, 1000),
		source:    cm,
		keyBuffer: make([]byte, 0, 200),
	}
}

// Destroy closes all worker channels and wait for workers to finish
func (cm *globalPipelineChannelMap) Destroy() {
	cm.globalMutex.Lock()
	for _, obj := range cm.globalMap {
		cm.deleteObject(obj)
	}
	cm.globalMutex.Unlock()
	cm.objectCounter.Wait()
}

func (cm *globalPipelineChannelMap) getOrCreate(keys []string, mergedKey string) pipelineChannel {
	cm.globalMutex.Lock()
	obj, found := cm.globalMap[mergedKey]
	if !found {
		cm.objectCounter.Add(1)
		obj = cm.createObject(keys, cm.objectCounter.Done)
		cm.globalMap[mergedKey] = obj
	}
	cm.globalMutex.Unlock()
	return obj
}

// LocalMap returns the local map. It shouild not be modified.
func (lm *localPipelineChannelMap) LocalMap() map[string]*pipelineChannelLocalBuffer {
	return lm.localMap
}

// GetOrCreate gets or creates a channel-worker and returns local cache of it
// The given key-set is assumed to be transient and will be copied if it needs to enter global map
func (lm *localPipelineChannelMap) GetOrCreate(tempKeys []string) *pipelineChannelLocalBuffer {
	tempMergedKey := lm.keyBuffer
	for _, tkey := range tempKeys {
		tempMergedKey = append(tempMergedKey, tkey...)
	}
	lm.keyBuffer = tempMergedKey[:0]
	// try to get existing cache by temp key, no new key string is created here
	if cache, found := lm.localMap[string(tempMergedKey)]; found {
		return cache
	}
	permKeys := util.DeepCopyStrings(tempKeys)
	permMergedKey := util.DeepCopyStringFromBytes(tempMergedKey)
	// pass copy of mergedKey here because it may be stored in global map
	newGlobalMap := lm.source.getOrCreate(permKeys, permMergedKey)
	newCache := lm.source.wrapObject(newGlobalMap)
	lm.localMap[permMergedKey] = newCache
	return newCache
}
